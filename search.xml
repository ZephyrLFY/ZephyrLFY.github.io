<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Leetcode-3.Longest Substring Without Repeating Characters]]></title>
    <url>%2F2019%2F02%2F05%2FLeetcode-3-Longest-Substring-Without-Repeating-Characters%2F</url>
    <content type="text"><![CDATA[Longest Substring Without Reapting CharactersLeetcode第三题 题目要求Given a string, find the length of the longest substring without repeating characters. Example1: 123Input: "abcabcbb"Output: 3 Explanation: The answer is "abc", with the length of 3. Example2: 123Input: "bbbbb"Output: 1Explanation: The answer is "b", with the length of 1. Example3: 1234Input: "pwwkew"Output: 3Explanation: The answer is "wke", with the length of 3. Note that the answer must be a substring, "pwke" is a subsequence and not a substring. 题目分析如题，输入一个字符串，输出其最长的子串长度，并且该子串中没有重复的字符。 代码实现version 0.1123456789101112131415161718192021222324252627class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; if(s.length() == 0) return 0; int result = 1; int count = 1; char start; for(int i = 0 ; i &lt; s.length() - 1 ; i++) &#123; start = s.at(i); while(s.at(i + count) != start &amp;&amp; i &lt; s.length() - 1) &#123; count++; if(i + count == s.length()) break; &#125; if(count &gt; result) result = count; count = 1; &#125; return result; &#125;&#125;; 为什么是version 0.1？很明显写错了……这里我脑子抽了，求的是与子串开头的字符不重复的子串，应当还要看后面的字符。 想到这里，我们自然想到了：从前往后遍历字符串的时候，每遍历到一个字符，就给它建一个哈希表，用来存储以它作为开头，目前所看的子串中的所有字符。之后看字符的时候就可以直接通过存入哈希表得到其是否重复了。 version 1.0 Hash Table1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; //傻逼输入处理 if(s.length() == 0) return 0; int result = 1; int count = 1; char start; char now; //从前往后字符串遍历 for(int i = 0 ; i &lt; s.length() - 1 ; i++) &#123; start = s.at(i); //每个字符创一个哈希表 unordered_map&lt;char, int&gt; temp; temp.insert(make_pair(start, count)); //cout &lt;&lt; i &lt;&lt; ": " &lt;&lt; start &lt;&lt; " "; //循环边界 while(i + count &lt; s.length()) &#123; now = s.at(i + count); //遍历器 unordered_map&lt;char, int&gt;::const_iterator got = temp.find(now); //之前没有的字符 if(got == temp.end()) &#123; count++; temp.insert(make_pair(now, count)); &#125; else break; &#125; //本次是否更长 if(count &gt; result) result = count; //cout &lt;&lt; count &lt;&lt; endl; count = 1; &#125; return result; &#125;&#125;; 虽然结果上应该是对了，但是总感觉这样应该是最笨的办法了，时间上应该很差 果然…… 算法改进可能大家还记得，算法与数据结构课上讲过这个题，当时有个滑动窗口的策略，我有点想不起来了，回去翻了翻笔记以后对hash表进行了一下改进。]]></content>
      <categories>
        <category>true</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-2.Add Two Numbers]]></title>
    <url>%2F2019%2F02%2F01%2FLeetcode-2.Add-Two-Numbers%2F</url>
    <content type="text"><![CDATA[Add Two Numbersleetcode第二题 题目要求You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: 123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 题目分析本题要求输入两个以链表形式保存的数，并在其中以倒序存放，输出也是以同样的形式，而这个结构在题目中已给定： 12345struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;; 所以最简单的方法就是两边同时顺着链表走，同样的位置相加。 需要注意的是，本题中数是倒着放的，所以不需要考虑数位的对齐问题，从右往左直接加就好。 运行环境Operating System：MacOS X Compiler：g++ 运行方式：bash 具体操作如下(编译，运行) 12$ g++ AddTwoNumbers.cpp -o running$ ./running 代码实现version 1.0首先，为了便于在本地机器进行测试，我写了创建链表和输出链表的函数 创建： 123456789101112ListNode* createList(string number) &#123; ListNode* start = new ListNode(number.at(0)); ListNode* l1 = start; number.erase(0,1); while(!number.empty()) &#123; l1-&gt;next = new ListNode(number.at(0)); l1 = l1-&gt;next; number.erase(0,1); &#125; return start; &#125; 输出: 12345678910void printList(ListNode* l1) &#123; string result = ""; while(l1-&gt;next != NULL) &#123; result.append(to_string(l1-&gt;val - 48) + "-&gt;"); l1 = l1-&gt;next; &#125; result.append(to_string(l1-&gt;val - 48)); cout &lt;&lt; "The result is : " &lt;&lt; result &lt;&lt; endl; &#125; 在这里大家可能注意到了l1-&gt;val - 48这个操作，这是为了让数字在转换成string的时候从ASCII码表中的数字对应到实际罗马数字。 然后开始正文。首先需要考虑的是，两个数的位数可能不一样，所以首先循环条件要对这个进行判断，在某一方结束之后，剩下的另一方的数都不需要做处理，直接接到结果的链表后面即可。 初版实现如下： 1234567891011121314151617181920212223242526272829ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* start = new ListNode(0); ListNode* l3 = start; bool carry = false; int value = 0; while(l1-&gt;next != NULL &amp;&amp; l2-&gt;next != NULL) &#123; value = carry ? l1-&gt;val + l2-&gt;val + 1 : l1-&gt;val + l2-&gt;val; if(value &gt;= 10) &#123; value = value / 10; carry = true; &#125; else carry = false; ListNode* temp = new ListNode(value); l3-&gt;next = temp; l3 = l3-&gt;next; l1 = l1-&gt;next; l2 = l2-&gt;next; &#125; if(carry) &#123; ListNode* temp = new ListNode(1); l3-&gt;next = temp; &#125; l3 = start-&gt;next; return l3; &#125; 上面的代码有个小问题，在进位的时候应该%10求余，/10是求除数。 这一版暂时没有写入最后临近结束的情况，即两条链表有空了的状态。 在某一方的ListNode的next指针为空时（或两者都），进行完这个节点的计算之后继续后移，指针为空的情况出现，所以将指针是否为空作为判断条件。 分析完后对代码进行补充。 version 2.0123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* start = new ListNode(0); //起始点 ListNode* l3 = start; //操作指针 bool carry = false; //进位标识 int value = 0; //先遍历直到两条链都没到空的地方 while(l1 != NULL &amp;&amp; l2 != NULL) &#123; value = carry ? l1-&gt;val + l2-&gt;val + 1 : l1-&gt;val + l2-&gt;val; cout &lt;&lt; l1-&gt;val &lt;&lt; " " &lt;&lt; l2-&gt;val &lt;&lt; " " &lt;&lt; value &lt;&lt; endl; //对进位进行处理 if(value &gt;= 10) &#123; value = value % 10; carry = true; &#125; else carry = false; //创建新的节点 ListNode* temp = new ListNode(value); l3-&gt;next = temp; l3 = l3-&gt;next; l1 = l1-&gt;next; l2 = l2-&gt;next; &#125; //如果两个数都空了 if(l1 == NULL &amp;&amp; l2 == NULL) &#123; //看要不要进位 if(carry) &#123; ListNode* temp = new ListNode(1); l3-&gt;next = temp; &#125; &#125; else &#123; //防止代码冗余，将剩余的那个数表示为left ListNode* left = l1 ? l1 : l2; l3-&gt;next = left; //如果有进位要求 while(carry) &#123; left-&gt;val += 1; if(left-&gt;val == 10) &#123; left-&gt;val = 0; //判断剩余的那个链是否结束 if(left-&gt;next == NULL) left-&gt;next = new ListNode(1); else left= left-&gt;next; &#125; else carry = false; &#125; &#125; l3 = start-&gt;next; return l3; &#125; 比较麻烦的地方在于，有时候会出现这样的情况： 一方虽然完了，按道理将剩下的那个数的剩下位数全部接在后面即可。但是如果有进位的话，很可能另一方的所剩数全是9，就会一直进位，所以需要一个while(carry)进行操作。最后根据是否进位来补最高位。 好了，考虑完所有情况了，来进行测试吧： 首先用比较简单的4321 + 4321 ??? 为啥结果是减过48的？ 经过检查，发现数字在读进来的时候就是加过48的，进行计算之后变成单位数字，但还是被减了48： 哦我懂了，减48的位置需要做一些调整，即读的时候减，输出的时候不用减了 即创建链表和输出链表改成这样： 1234567891011121314151617181920212223ListNode* createList(string number) &#123; ListNode* start = new ListNode(number.at(0) - 48); ListNode* l1 = start; number.erase(0,1); while(!number.empty()) &#123; l1-&gt;next = new ListNode(number.at(0) - 48); l1 = l1-&gt;next; number.erase(0,1); &#125; return start; &#125; void printList(ListNode* l1) &#123; string result = ""; while(l1-&gt;next != NULL) &#123; result.append(to_string(l1-&gt;val) + "-&gt;"); l1 = l1-&gt;next; &#125; result.append(to_string(l1-&gt;val)); cout &lt;&lt; "The result is : " &lt;&lt; result &lt;&lt; endl; &#125; 虽然这对结果没什么影响就是了。 于是进行测试吧！ 4721 + 00001，应得47211： 4721 + 8278，应得20001: 4727 + 8278，应得20061: 暂时没啥问题，提交试试： emmmm看了看代码，发现问题了： 12345678910111213141516while(carry) &#123; left-&gt;val += 1; if(left-&gt;val == 10) &#123; left-&gt;val = 0; cout &lt;&lt; left-&gt;val &lt;&lt; endl; //判断剩余的那个链是否结束 if(left-&gt;next == NULL) left-&gt;next = new ListNode(1); else left= left-&gt;next; &#125; else carry = false; &#125; 就是在剩余一条链表的时候，如果最后一位产生了进位，那么在进入最后一次循环的时候，还要把停留在前一次循环的left链表的val加一，导致了出错… 改成这样应该对了： 12345678910111213141516171819while(carry) &#123; left-&gt;val += 1; if(left-&gt;val == 10) &#123; left-&gt;val = 0; cout &lt;&lt; left-&gt;val &lt;&lt; endl; //判断剩余的那个链是否结束 if(left-&gt;next == NULL) &#123; left-&gt;next = new ListNode(1); carry = false; &#125; else left= left-&gt;next; &#125; else carry = false; &#125; 再试一次： 卧槽…………………………………1.1%……………………………………. 改进算法去判断，去循环！！！！ 代码需要瘦身一下，而最费时间的就是每次的判断。 对啊，仔细想想，为什么某一方链表结束了就操作不一样了呢？ 我直接认为它剩下的位数都是0好不好！费那么大劲干嘛！ version 3.01234567891011121314151617181920212223242526272829303132333435ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* start = new ListNode(0); //起始点 ListNode* l3 = start; //操作指针 int carry = 0; //进位标识 int value = 0, val1 = 0, val2 = 0; while(l1 || l2) &#123; val1 = l1 ? l1-&gt;val : 0; val2 = l2 ? l2-&gt;val : 0; value = val1 + val2 + carry; //对进位进行处理 if(value &gt;= 10) &#123; value = value % 10; carry = 1; &#125; else carry = 0; //创建新的节点 ListNode* temp = new ListNode(value); l3-&gt;next = temp; l3 = l3-&gt;next; if(l1)l1 = l1-&gt;next; if(l2)l2 = l2-&gt;next; &#125; if(carry) &#123; l3-&gt;next = new ListNode(1); &#125; return start-&gt;next; &#125; 虽然看起来还是挺长，但是从63行变到35行，已经不错了 赶紧试试： 提升了这么大？？我是没懂，你们呢？ version 4.0????重新审视一遍代码，我发现while循环里，最开始判断l1&amp;l2的语句，以及最后移向next的时候判断l1&amp;l2可以合并一下，即： 123456789101112131415if(l1) &#123; val1 = l1-&gt;val; l1 = l1-&gt;next; &#125; else val1 = 0; if(l2) &#123; val2 = l2-&gt;val; l2 = l2-&gt;next; &#125; else val2 = 0; 但是提交了之后没变，还是91%…..看来一次判断影响不了太多]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-1.Two Sum]]></title>
    <url>%2F2019%2F01%2F04%2FLeetcode-1.Two-Sum%2F</url>
    <content type="text"><![CDATA[Two Sumleetcode第一题 题目要求Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 题目分析输入一个整数vector，和一个目标整数，输出该vector中两项相加等于目标整数的两项索引(即下标) 题目竟然没说如果没找到的话怎么输出？？？ 然后一个数不能用两遍 看到这个题，脑子里首先想到的就是暴力解法，即从前往后遍历，开销挺大的，但是一时间又想不到别的解决办法，打算先写出来最基础的方法 代码实现: Brute Forceversion 1.01234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; int start = 0; vector&lt;int&gt; result(0); while(nums.at(start) &gt; target) &#123; start++; if(start == nums.size()) return result; &#125; int i = start; int j = start; for(; i &lt; nums.size(); i++) &#123; for(; j &lt; nums.size(); j++) &#123; if(nums.at(i) + nums.at(j) == target) &#123; result.push_back(i); result.push_back(j); return result; &#125; &#125; j = start; &#125; return result; &#125;&#125;; 结果… 检查后突然想起来 整数是包含负数的，这段代码中首先将start定为遍历开始的位置，而定start位置的时候是通过将其定位在vector中第一个比目标小的数开始的，而start之前被跳过的数本来有机会与后面的负数相加仍然等于目标。 看来一开始想着定位start可以节省一点开销的想法是不现实的 于是将start相关段删掉之后又提交，发现还是有问题？？？ 不过这次问题比较明显，我忘记了题目中的“一个数不能重复使用”，于是将代码修改如下： version 2.012345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; result(0); int i = 0; int j = 0; for(; i &lt; nums.size(); i++) &#123; for(j = i + 1; j &lt; nums.size(); j++) &#123; if(nums.at(i) + nums.at(j) == target) &#123; result.resize(2); result[0] = i; result[1] = j; return result; &#125; &#125; &#125; return result; &#125;&#125;; 我就知道，这方法也太蠢了，毕竟 Time complexity : O(n^2) 改进: Hash Table根据第一种算法的原理，我们首先拿到一个数，接下来在vector中遍历的过程其实就是找第一个数所对应的结果，每个数只能有一个结果与其对应(用target减去其) 所以自然可以联想到，拿到第一个数的时候，是否可以直接在vector中直接找其对应的那个结果呢？有就说明成功，没有就失败。 因为Hash表的特殊性质，在查找第二个数的时候会比第一种的遍历方式快许多，所以这样的话时间复杂度会低，因为不需要第二轮遍历了——O(n) 在而要实现查找第二个数以后直接拿到其索引值，就需要在创建哈希表的时候直接填入。 代码如下： version 3.012345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; result(0); int i = 0; unordered_map&lt;int, int&gt; temp; for(i = 0; i &lt; nums.size(); i++) &#123; temp[nums.at(i)] = i; &#125; for(i = 0; i &lt; nums.size(); i++) &#123; cout &lt;&lt; nums.at(i) &lt;&lt; endl; unordered_map&lt;int, int&gt;::const_iterator got = temp.find(target - nums.at(i)); if(got != temp.end() &amp;&amp; got-&gt;second != i) &#123; result.resize(2); result[0] = i; result[1] = got-&gt;second; return result; &#125; &#125; return result; &#125;&#125;; 如上述代码所示，将vector的值作为键，索引作为值，这样可以使用hash map的find函数直接找到有没有对应的答案，并得到其值。 结果也确实比第一种办法好了不少： 改进: One-pass Hash Table上面方法其实有点问题：在创建map的时候，只是做了遍历，插入 其实我们也可以在创建的同时查看是否对应的答案已经在map里了，有就立即返回，没有就继续遍历插入。 这样我预计会极大提升速度，因为很多时候答案会在创建的map中比较靠前的位置，这样会节省后续的创建开销。 如果答案在后面也无所谓，最差的情况就是和第一个Hash算法一样。 而不管怎么样，都不用再对vector进行第二次遍历了 代码如下： version 4.01234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; result(0); int i = 0; unordered_map&lt;int, int&gt; temp; for(i = 0; i &lt; nums.size(); i++) &#123; temp[nums.at(i)] = i; unordered_map&lt;int, int&gt;::const_iterator got = temp.find(target - nums.at(i)); if(got != temp.end() &amp;&amp; got-&gt;second != i) &#123; result.resize(2); if(i &lt; got-&gt;second) &#123; result[0] = i; result[1] = got-&gt;second; &#125; else &#123; result[0] = got-&gt;second; result[1] = i; &#125; return result; &#125; &#125; return result; &#125;&#125;; 结果有些问题： 可见，如果采用我这种写法的话，若vector中有重复元素，在创建map的时候就不会插入这个元素。 所以和Hash1有区别的地方在于，该算法要先判断当前要插入的元素有没有答案，是的话返回，不是的话反正以后也不会用到，不插入也没有影响。 version 5.01234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; result(0); int i = 0; unordered_map&lt;int, int&gt; temp; for(i = 0; i &lt; nums.size(); i++) &#123; unordered_map&lt;int, int&gt;::const_iterator got = temp.find(target - nums.at(i)); if(got != temp.end()) &#123; result.resize(2); if(i &lt; got-&gt;second) &#123; result[0] = i; result[1] = got-&gt;second; &#125; else &#123; result[0] = got-&gt;second; result[1] = i; &#125; return result; &#125; temp[nums.at(i)] = i; &#125; return result; &#125;&#125;; 结果让人十分满意： 进一步提升？翻了翻评论区，好像没有找到更好的方法了，但是明显，还有20%多的c++代码跑的比我快，实在不懂为啥。博文发上来之后我自己也想一想Hash Table有没有什么更快的写法，然后研究一下评论区的代码… 这是Leetcode之旅的第一题，难度低，但是也有很大的提升空间，从一开始的120ms到8ms，成效明显。 不过我没想到O(N*logN)的算法，有想法的同学可以给我留言或者联系我]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018Summary]]></title>
    <url>%2F2018%2F12%2F31%2F2018Summary%2F</url>
    <content type="text"><![CDATA[2018年12月31日，23点45分。小时候对于跨年这种事，一直没什么特别的感想Just a new year huh? So what’s different?但是随着自己慢慢变老，有好多事情记不住了，所以总结总结还是挺有必要的Here we go. And…哎，我是真的想家了。 BTW, 电脑端的话左边目录直接跳就完事了嗷 18回顾 干了啥？Games今年好游戏不少，但是今年比较忙，所以没玩几个，就列举印象最深的几个8: Bloodborne！！！！！ 我永远喜欢玛丽亚师姐！！！ 说真的，不吹不黑，心中的PS4平台最佳。剧情特别黑暗，玩的时候全程有种孤独而恐惧的绝望…而且，这个游戏的画风是这样子的： 更不堪入目的画面我就不贴了…什么长了满满一头眼睛的巨大野猪啊，一堆肉堆叠成的不可名状的物体啊什么的…当然我自己一点都不排斥哈哈哈(虽然玩的时候经常起鸡皮疙瘩) 不过和别的魂系列一样，这游戏最大的魅力还是屠杀猎物的乐趣： 上面这张是我这辈子打过最苦的boss战，不想回忆了… 是不是打完boss的场景还蛮震撼的？ 正是这种魅力，导致我寒假回家那天熬了一晚上夜把它打通(因为寒假PS4在同学家)，差点把飞机误了hhhh 不过难度确实有点太高，我以为我这种Dark Souls3四周目老玩家能横行霸道，结果被虐的死去活来 不过管他呢，血源天下第一就完事了(迫真！) Dark Souls Remastered 问你美不美，huh？ 美吧，但是没别的美图了…… 没办法，毕竟这是十年前的游戏了，虽然是重制版，但remastered 毕竟不是remake，画面还是有些欠缺，但是这款魂系列的开山鼻祖(恶魂：Fuck U)真的不能不玩。 作为魂系列忠实粉丝，我甚至把游玩当作一种朝圣（是不是太中二了 但是由于老玩家的自信，我基本没加血，一路被各种薪王制裁，尤其是最后的马薪王。 不过——哼，再强也不是被我治得和儿子一样(我甚至录了段视频传了b站hhh) 萌新翻滚流吊打马拳王 这款游戏我也不多评价了，全是情怀，通关之后对魂系列的世界观有了更清晰的认识，而且地图设计太完美了，据说有人把魂1的地图串起来发现是连通图不是离散数学 怎么样，这设计我反正服了 God of War 年度最佳游戏不是没有理由的 甚至我前两天玩到荒野大表哥的时候，心里都是这么想的“战神更配得上这个称号” 之前旁观过舍友玩旧版的战神3，画面和操作实在是爱不上，太老了… 但这次圣莫妮卡开启的新三部曲，制作诚意都快溢出屏幕了 啊，这水，啊这粒子效果 包括剧情，人物塑造的丰满度，流程的合理性，战斗系统的丰富性与流畅性，2018简直没一个能打的 最大的亮点是，这作用了一镜到底的策略： 简而言之，就是从开始游戏到打通关，没有看不到人物的加载画面，这有多牛啤大家应该都懂(尤其是参与创作过毛概视频的童鞋们) 而且，本身这种英雄老去的剧情就很让人着迷(参考休杰克曼，金刚狼3) 不仅如此，本作包含了许许多多的情怀点(具体不说了，剧透)，在不少地方还有对剧情的影射与暗示，游玩体验极棒 而且博主对北欧神话有些许了解，当时还正好看完雷神3，玩的时候竟有点违和感 不多说了，打败大表哥夺冠的游戏也不需要太多证明。你老父亲终究是你老父亲 奎秃子 Movies动画COCO 什么？你没看过？ 赶紧去看！不多说了，属实难遇到的好片，剧情不要追求太多，毕竟动画片，做太深奥小孩子们怎么看？ 据说最近的寄居侠也好评如潮，我打算最近勾引一个人去观赏一下嘿嘿嘿 国产片动物世界 烂片。真的，我还是和一个漂亮妹纸去看的，我服了，把我看自闭了… 无双 还可以，金城武周润发是真滴帅，节奏也不错，就是…稍微有那么一点狗血 Aquaman，Avengers, black panther等超级英雄看得都挺爽的…没啥可说的，剧情其实都一般吧 哦对不要忘了小贱贱！deadpool还是很有排面的 老友记不是电影但还是放进来了 今年发现的最大的宝藏！ 超级搞笑，还对英文口语有帮助 为什么我之前没发现？ 强烈推荐，byr bt上有资源，整整十季看个爽 Books其实今年最傻逼的就是书看的太少了，就两本… 嫌疑人X的献身 东野圭吾备受好评的一本书，确实有点东西，这小子写书的思维逻辑特别强，不过从书的质量上讲，比不上他的白夜行(个人意见) 解忧杂货店 没错，还是东野小哥哥的书，这本书…只能说，太暖了，我看的过程中哭了5次我是不会说出来的…据说与之对应的他写过一本描写人性恶的书叫《恶意》，我打算寒假看看 19年一定要多看书！Kindle不能吃灰了 Others其他值得记的事情： 返校宣讲： 寒假帮小破邮回高中宣讲了一波，没找队友，反响还挺好的，虽然不知道帮你邮坑拉了多少同学，起码还是挺开心的，回母校见见老师，跟学弟学妹吹吹比什么的hhh 足球： 众所周知博主是C罗铁杆球迷，今年他再度捧欧冠确实挺开心的，但是去了尤文emmmm反正从那之后我没看过球赛，一方面是因为忙，另一方面，我看球8年，很大程度上就是看有C罗的皇马。现在我最喜欢的球队已经不存在了呜呜呜 BTW,世界杯上葡萄牙3:3西班牙那场小组赛要多精彩有多精彩，尤其是对于一个C罗粉，过年一样哈哈哈 学了啥作为学生，这个问题当然最重要了。 说实话，前半年我活得挺颓的其实，没有人生目标，每天混吃等死。但是下半年决定要出国读研之后，感觉又回到了高三那年(所以说人真的要有目标)这个学期感觉还是学了不少东西的： C++宠物小精灵对战系统 虽然只是我们这个学期程序设计课的大作业，但是我感觉对我的帮助是最大的。Socket通信，数据库基本操作，UI设计，Qt信号与槽，键盘事件的处理，各种表项控件的处理，音乐的播放，多线程…这些都是我第一次接触。所以从接触新事物的角度看，这个程序帮助了我真的很多。 哦对了差点忘记了，还有写完之后的文档编写，包含了Markdown语法，基于node.js的e-book电子书的制作(为了实现PDF格式的文档中目录的超链接) emmm往更远一点说，还有对Github的管理以及使用 可能上面这些内容，各位大佬早就接触并已掌握，但对于我来说，还是蛮满足的，这种接触与掌握新事物的喜悦，可能也是驱动各位程序猿的最大动力来源吧 UML建模标准学习 本学期Java选修课必备技能，不得不学… 只能说，有点反人类，可以的话并不想学 虽然其中一些东西还蛮有用的，比如类图呀用例图什么的，别的我感觉手工draft都能应付得了。 Python一小部分知识 本学期网络存储技术需要的技能 本来呢我想着做出这个项目，但是小精灵占用了我太多时间，到最后可以专心写的时候已经只剩一个礼拜了。 一开始抱着做多少是多少的心态，实现出基于TCP的C/S，实现了文件传输，但是要做异步IO的时候卡住了，也不知道是不是我暂时水平有限，实在是搞不出来 Google上也没找到像样的demo，不过有可能是因为时间紧迫所以找得比较急 反正在第三天放弃了… Python学了一些皮毛，至于asyncio, coroutine, daemon… 呵呵呵：） 对Mac OSX，bash，homebrew的熟悉与使用 博主有两台笔记本，一台是傻大黑粗的17寸游戏本，一台是16乞丐版mbp，初中的时候其实买过一台mbp，但是当时实在是不会折腾，并且从小接触window系统，早就用惯win下的操作逻辑了，对mac实在是不感冒 现在这台mac其实也是因为游戏本不方便自习才买的，果然从大一开始它的使命就是XCode和C代码，偶尔浏览浏览网站 但是这学期开始好好学习之后，为了方便自习，实现本学期所有内容均可以在Mac上学习，博主开始利用Google，Stackoverflow等平台解决了很多环境的配置问题，以及Unix下属系统的很多命令行操作——嗯…毕竟桌面时刻开着bash才看起来像计算机专业的学生嘛 123456&gt; MacBook-Pro:~ zephyr$ brew list&gt; gdbm nasm openssl readline&gt; icu4c nginx pcre sqlite&gt; libyaml node python xz&gt; MacBook-Pro:~ zephyr$&gt; 那么这学期配了点啥呢？涉及到了什么东西呢？ PATH环境变量(还有bashrc,vimrc) Vim编辑器 Xcode编辑器 Typora编辑器 lex，yacc等编译器小工具 nasm汇编环境 dosbox汇编环境 大名鼎鼎的homebrew python3环境 java环境 是不是还不少？我感觉之前两年对我的mac简直就是浪费！ SSR科学上网 包括搭建VPS，手动在服务器搭ssr环境，添加ssh emmm这部分不能多说，如果有人想知道的话我可以寒假写个教程，但是没啥必要，因为我只会搭Mac环境，win的话随便Google就有了 然而，IP很容易被墙，不知道什么时候就得手动更换服务器的IP地址了 个人博客的搭建 搭这个博客的初衷是想作为一个技术博客，因为很多程序员都有自己的博客，而且确实有一些东西(比如万恶的配环境)如果不及时记录的话以后极有可能遗忘，到时候再Google半天太窒息了 而且一味的保存人家的教程在bookmark里也么的排面 so。。 Eat your own dog food. 本网站的实现经过了如下步骤： powered by hexo的个人网站 github添加个人主页，包括ssh登录设置 购买个人域名，并添加DNS解析 修改网站主题，美化网站 网络图床的搭建 这部分也挺麻烦，有人需要的话可以寒假出教程，但是同样…Google就完事了，关键步骤还是得自己来做 而且教程这种东西…说不好听点，一个人有一个人的解决办法，但是看教程的人有多少环境，多少问题，博主肯定是解决不了全部问题的，那为什么不问问神奇的Google呢？ 买了啥Bose QC35II 因为博主打算出国，需要练托福听力，一个好的降噪耳机必不可少 之所以挑这个而不是sony的新款——博主头大啊！对舒适度的需求高 正好我的Airpods也该退休了，使用率太高，而且这也快两年了，电池老化严重 购买之后的使用体验也是十分满意，降噪效果十分出色，有时候想睡觉，舍友声音大也可以戴起来安稳入眠 音效的话…当了三年耳机发烧友，我只能说，万元以下的头戴，听个响就行了，何况是蓝牙，降噪 不过有个副作用——买个床帘搭起来，再配上这玩意，睡一觉醒了不知道是几点hhhh 个人域名 如果搭建完博客之后不买域名的话，你的网站会是这样： https://yourname.github.io/xxx/xxx/... 为了逼格也得买呀，虽然也不贵 VPS服务器 不多说了，自搭SSR科学上网必备 护肤品 暑假和一个高中同学玩，感觉他皮肤变得特别好，心生羡慕，产生了护肤的想法 于是后来了解了很长时间，入了金盏花，SKII，科颜氏白泥，Lab’s乳液，安耐晒，Jackblack护唇膏，Freeplus氨基酸洗面… 效果还是挺好的，我自己每天看所以没有特别大的感触，等回家让爸妈看看hhh 18总结18年最后一天属实给我留下了不好的印象。 早晨6点半起床，准备去上最后一节TOEFL课，一翻朋友圈，WTF？有个舍友昨晚两点多脱单了呵呵呵，我一点都不知道，直接被雷击倒了不想去上课：） 18年还是单身的一年。 我做了不少尝试，但是都无功而返，基本都是我的问题。有的感觉聊不来，有的看试了两天突然觉得不好看…没有一个迈出过多少步伐。可能还是没有遇到吧，我也不想强求了，我只想… 周围的同学不要以为我是Gay了！你们这么说会让我更难找的！ 喜欢健身，搞搞护肤，只能说明我是好男孩，不代表我是gay：） 不过 说了这么多，其实觉得18年还是挺满足的，前半年起码玩得开心，后半年因为有了目标而充实起来，每天学新知识。大三重新调整了宿舍，舍友们都是学霸，学习氛围也很好，每天生活虽然单调但也不会无聊。毕竟自己选择的路，苦累又怎么样呢，还不是得走。 就这样吧，提前愿19顺利。 (赣，写到这看了看表已经半夜2点了，你们跨年的时候都在干嘛？) 19展望 Some Goals GPA 首先，对于出国党当然是刷gpa，尤其是对于我这种前两年没有好好学的傻屌来说，刷GPA真的好难… TOEFL 首考2月24号山西大学，不多说了，假期刷就完事了 目标就定100分吧，我的gpa估计也用不着多高的T分 GRE 开学之前把T考完，开学就得接着学G了，还是得周六周日每天6点半起呜呜呜呜呜呜 虽然不用像托福一样忍受冬天的早晨了 霾+冷，保持微笑：） 找实习 暑假得找实习，我现在很气为什么这种事18年没有做！ 有机会的话，9月开学进实验室 找女朋友 认真的讲，19年我不要单身了(迫真) 看看我舍友，18年最后一天给我暴击，佛了。 但是自从开始准备出国之后我这么宅，真的…能找到么… My Plans这里暂时先写寒假的plan，写的太多太长的话不现实，以后肯定会有调整 Leetcode 这也是我开启更博客的初衷，不管是为了应聘还是考试，我觉得紧跟各位计算机大牛们刷题肯定是对的。 暂定计划，至少两天一道题，第一天精做，第二天关于所做的题更新博客 这样量不大，但是本来寒假就一堆事呵呵 TOEFL复习 算了一下当前进度，大概在2月前能背完第一轮单词。初步计划是假期把单词过两遍， Listening: 每天2篇lecture1篇conversation Speaking: 准备各任务模版，坚持刷TPO Reading: 中国学生，刷就完事了 Writing: 和Speaking类似，准备模版，刷TPO，具体计划考完试再定 新编程语言学习 Java 或者Python 待定 我个人感觉Python有意思一点。 iOS编程尝试 前几天尝试了一下写了个特别简单的“自闭”小程序，更新了一次系统就不能用了(虽然也没多大用) 假期实现点比较有意义的东西 我发现iOS app的UI设计和Qt挺类似的，可能UI设计都是这么一套？ 练练小提琴，健健身 这学期琴没带来学校，好久没拉了还怪想它的 健身就不说了…这垃圾学校健身房，连个自由深蹲架都没有练尼玛呢 而且确实挺忙的一周不一定能去一次 回家趁有时间好好练练，现在腹肌都没那么明显了呜呜呜呜 Over2019年凌晨02:53，终于写完了，用时三小时出头 果然，19年第一天就熬夜：） 不过呢，我觉得还是蛮值的，梳理了一下去年发生的事感觉挺幸福，虽然已经在冷冷的楼道里困成傻子了(半夜在楼道里可以观赏各种起床上厕所的奇怪穿着) 而且更重要的是把想了好几天的新年目标定了 至少我感觉，脑子里空空的一觉睡过去，对跨年来说少了点敬意与意义 现在博主终于可以安稳地进入小被窝里了嘿嘿嘿 不过因为一直在写这篇文章，跨年的时候大家的祝福我都没有及时接收到，有点抱歉，在这里统一祝大家新年快乐，万事顺利，越来越好 (长大了才发现，祝福词真是越简单越好) 不管将要迎来的是怎样的一年 I’m ready. 再见18，你好19。 :-)]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
